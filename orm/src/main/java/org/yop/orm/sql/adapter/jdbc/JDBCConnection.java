package org.yop.orm.sql.adapter.jdbc;

import org.yop.orm.exception.YopRuntimeException;
import org.yop.orm.exception.YopSQLException;
import org.yop.orm.sql.BatchQuery;
import org.yop.orm.sql.Config;
import org.yop.orm.sql.Parameters;
import org.yop.orm.sql.Query;
import org.yop.orm.sql.adapter.IConnection;
import org.yop.orm.sql.adapter.IRequest;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * A JDBC connection.
 * <br>
 * Read the reason for this in the {@link IConnection} interface documentation.
 */
public class JDBCConnection implements IConnection {

	/** The underlying JDBC connection */
	private final Connection connection;

	/** Default config is read from system properties, with default values. */
	private Config config = Config.DEFAULT;

	/**
	 * Default constructor : please give me the JDBC connection !
	 * @param connection the JDBC connection to use
	 */
	public JDBCConnection(Connection connection) {
		this.connection = connection;
	}

	/**
	 * Set an explicit config for this connection (SQL separator, batch inserts, show sql...)
	 * @param config the config to set
	 * @return the current JDBC connection instance, for chaining purposes
	 */
	public JDBCConnection withConfig(Config config) {
		this.config = config;
		return this;
	}

	/**
	 * Get the connection config : {@link #config} that might have been set using {@link #withConfig(Config)}.
	 * @return the current {@link #config} instance
	 */
	@Override
	public Config config() {
		return this.config;
	}

	/**
	 * {@inheritDoc}
	 * <br>
	 * See {@link Connection#close()}
	 */
	@Override
	public void close() throws SQLException {
		this.config.getDialect().onClose(this);
		this.connection.close();
	}

	/**
	 * {@inheritDoc}
	 * <br>
	 * <u>JDBC Implementation</u> :
	 * <br>
	 * Prepare the statement to be executed using the query.
	 * <br>
	 * The safe alias SQL query is used and parameters are set.
	 * <br>
	 * You are ready to go :-)
	 * @throws YopSQLException an Error occurred preparing the statement with the given connection
	 */
	@Override
	public IRequest prepare(Query query) {
		String[] idColumns = query.getAutogenIdColumn();
		PreparedStatement statement;

		try {
			if (idColumns.length > 0) {
				statement = this.connection.prepareStatement(query.getSafeSql(), idColumns);
			} else {
				int autoGeneratedKeys =
					query.askGeneratedKeys()
					? Statement.RETURN_GENERATED_KEYS
					: Statement.NO_GENERATED_KEYS;
				statement = this.connection.prepareStatement(query.getSafeSql(), autoGeneratedKeys);
			}

			while (query.nextBatch()) {
				for (int i = 0; i < query.getParameters().size(); i++) {
					Parameters.Parameter parameter = query.getParameters().get(i);
					if (Query.Type.INSERT == query.getType() && parameter.isSequence()) {
						throw new YopRuntimeException(
							"Parameter [" + parameter + "] is a sequence !"
							+ "It should not be here. This is probably a bug !"
						);
					}
					query.getConfig().getDialect().setParameter(statement, i + 1, parameter);
				}

				// Well, this is embarrassing.
				// Using addBatch with some drivers does not seem to work well with a single batch entry.
				if(query instanceof BatchQuery) {
					statement.addBatch();
				}
			}
		} catch (SQLException e) {
			throw new YopSQLException("Exception preparing statement for query [" + query + "]", query, e);
		}

		return new JDBCRequest(statement, query);
	}

	/**
	 * {@inheritDoc}
	 * <br>
	 * See {@link Connection#getAutoCommit()}
	 */
	@Override
	public boolean getAutoCommit() throws SQLException {
		return this.connection.getAutoCommit();
	}

	/**
	 * {@inheritDoc}
	 * <br>
	 * See {@link Connection#setAutoCommit(boolean)} ()}
	 */
	@Override
	public void setAutoCommit(boolean autocommit) throws SQLException {
		this.connection.setAutoCommit(autocommit);
	}

	/**
	 * {@inheritDoc}
	 * <br>
	 * See {@link Connection#commit()}
	 */
	@Override
	public void commit() throws SQLException {
		this.connection.commit();
	}

	/**
	 * {@inheritDoc}
	 * <br>
	 * See {@link Connection#rollback()}
	 */
	@Override
	public void rollback() throws SQLException {
		this.connection.rollback();
	}
}
